## **循迹算法**

### **算法实现：此循迹算法经过我蹲在实验室一楼一个月，已经研究出了一套移植性较高的算法。通过路线图，此算法包括：循迹、转弯、标记记忆、脱线等部分**

## 八路

## 白线-1 黑线-0

①循迹最基本的要求就是车可以循迹且不脱离循迹轨迹，由于我们的结构是普通的两轮结构，这也存在了打滑、重心不稳的大问题，也就是说我们的车走直线都有点问题，解决的办法就是程序解决，也就是利用程序将车体打滑的轨迹强行纠正。大致思路就是利用前头3-6路传感器检测，车体偏移时传感器会检测到，检测到后就做出纠正，左偏就右纠正，右偏就左纠正，当然，纠正的程序需要增加一些判断机制，这样可以提高车的稳定度，不容易出现纠正过大导致出线的情况。纠正的车速也需要调节，不易过小，亲测是纠正速度大一点，这样比较有效，过小的话容易出现无法纠正的情况。建议采用是‘同向差速纠正’，最好不要用‘反向差速纠正’，同向纠正就可以保证车体运动轨迹一直保持向前，即使纠正过头也不会出现大幅度转弯。

```c
//纠正模式一（正头）        //1 2 3 | 4 5 6                
                     //  1 2 3 4 | 5 6 7 8       
                        if(FA5==1&&FA4==0&&FA3==0)        //往右偏-八路              
                        {
                                motor1 = 0;
                                motor2 =-5000;
                                motor3 =-3700;
                        }
                        if( FA5==0&&FA4==0&&FA3==1 )                        //往左偏
                        {
                                motor1 = 0;
                                motor2 =-3700;
                                motor3 =-5000;
                        }
                        if(FA5==0&&FA4==1&&FA3==0)
                        {
                                motor1 = 0;
                                motor2 =-3400;
                                motor3 =-3400;
                        }
                        Set_Pwm(motor1,motor2,motor3);
                        motor1 = 0;
```

 ②ok,第二部分就是标记路线了，所谓标记路线就是对一些路口进行标记，达到记忆的效果。经过我趴地研究，用局部路口标记的方式和特殊路口标记效率最大。所谓局部标记就是省略一些路口，不进行标记，特殊标记就是对T型，倒T等路口进行标记。标记如下图所示：

![微信截图_20190707152943.png](https://xiaopingtou.net/data/attach/1907/uufeeczkida0r2zriz1fax4ncdiyikvh.jpg?t=1689908439648)

大家看标记图和路线图，可以发现我把一些路口省略掉了。附上从绿 {MOD}区域出发到达标记1的代码。从代码上可以发现我用了二次检测的原理，也就是吧、判断了两次，嗯，这样可以提高系统的稳定性和判断的严谨性。首先看第一行 FC14 == 0 && FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 0，这个是运动到标记1位置，然后FA5 == 1 && FA3 == 0 && FC14 == 0二次判断，然后控制电机差速转向，注意time = 1这个语句，它起到很大作用，也就是保证转弯时车不会脱线，做过差速转弯的循迹小车的同学应该都知道，差速转弯十分不稳定，很容易脱线，基本要靠delay函数延迟（但是不好）加入第二个标记位判断可以保证车体脱线时硬生生“掰正”回来，这就是双标记位的使用，十分有效

```c
//顶角转弯直走1   黄 {MOD}圈
             if(FC14 == 0 && FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 0)
                 {
                    delay_ms(10);
                     if(FA5 == 1 && FA3 == 0 && FC14 == 0)
                      {
                            motor1 = 0;
                            motor2 = 4800;
                            motor3 = -4500;
                            Set_Pwm(motor1,motor2,motor3);

                             time = 1;
                       }
                  }       
```



③从黄 {MOD}区域到红 {MOD}区域，标记位2，从黄区-->红区，会经过几个路口，我采用忽略标记，不进行标记，大家仔细看程序会发现Flag和 time两个标记位在不断转换，它的作用就是上面提到的对差速转弯的打滑车进行强行掰正，这个是我们小组经过不断努力（掉了好多头发研究出来 的循迹模式-->硬掰模式,

大家主要看深蓝 {MOD}的代码那里，其他代码是机械臂抓物块以及停止的，可以不看，贴出来是给大家更加直观地知道整个执行流程以及两个标记位的互换。一般红外循迹小车都是利用delay函数来差速转弯，这个虽然可以，但是一旦车打滑就会出现转弯过大或者过小的情况，这样会影响后续的标记，十分麻烦（![img](https://xiaopingtou.net/data/attach/1907/bjlxkuvdvc0fxjdyp9l9vvukaiih56eg.jpg?t=1689908439648)亲测不可行)，但是利用两个标记位切换的话就可以实现转弯即使过大过小都可以硬生生掰会循迹路线，100%稳定且可行。

```c
//黄 {MOD}口停                       
                        if(FC14 == 0 && FA5 == 1 && FA3 == 1 && time == 1)
                        {
                                delay_ms(20);
                                if(FC14 == 0 && FA5 == 1)
                                {
                                       	Flag = 30;
                                        motor1 = 0;
                                        motor2 = 0;
                                        motor3 = 0;
                                        Set_Pwm(motor1,motor2,motor3);
                                       
                                        //0号盘下去
                                        //舵机归零

                                                                               
                                        motor2 = -3700;
                                  		motor3 = -2000;
                                        Set_Pwm(motor1,motor2,motor3);
                                        delay_ms(200);
                                       	time = 2;
                                }                                                               
                }
                       
               
//蓝 {MOD}口停
                if(FC14 == 1  && FA5 == 0 && time == 2)
                        {
                                delay_ms(20);
                                if(FC14 == 1&&FA5 == 0)
                                {
                                        Flag = 31;
                                        motor1 = 0;
                                        motor2 = 0;
                                        motor3 = 0;
                                        Set_Pwm(motor1,motor2,motor3);
                                       

                                        motor2 = -3700;
                                  		motor3 = -2000;
                                        Set_Pwm(motor1,motor2,motor3);
                                        delay_ms(100);
                                        time = 3;
                                }
                        }
                       
//红 {MOD}转弯               
              if(FC14 == 0 && FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 31)
                                {
                                        delay_ms(10);
                                        if(FA5 == 1 && FA3 == 0 && FC14 == 0)
                                        {
                                                motor1 = 0;
                                                motor2 = 4800;
                                                motor3 = -4500;
                                                Set_Pwm(motor1,motor2,motor3);

                                                time = 4;
                                        }
                                }        
                               
                                       
//红 {MOD}角停止       
            if(FC14 == 0 && FA5 == 1 && (FA3 == 1 || FA2 == 1 || FA4 == 1) && time == 4)
                        {
                                delay_ms(10);
                                if(FC14 == 0 && FA5 == 1)
                                {
//                                                Flag = 33;
                                                motor1 = 0;
                                                motor2 = 0;
                                                motor3 = 0;
                                                Set_Pwm(motor1,motor2,motor3);
                                                delay_ms(300);
                       
                                        Flag = 33;
//                                                time =  6;                               
                        }       
                }
```



 ④标记4--->标记9思路和上面一模一样，仅仅区别在一些标记延迟和标记判断上，区别不大，主要是2个标记位的切换需要技巧切换，不然车就会“迷路”，或者一直转圈圈，这里主要说下“脱线”的方法，如果觉得整段路一直循迹很无聊。那咋们就可以考虑下“脱线”，脱线，顾名思义就是脱离循迹路线一段时间后继续回到循迹路线，继续循迹。这个应用在多段短路线转弯口十分有用，因为多路的短转弯口如果还是照以前乖乖循迹就真的有点笨笨了，这样标记起来麻烦又容易出现问题，那还不如考虑脱线到稳定直线或者长转弯口再继续循迹（以前就是照旧没有脱线，然后出现很多问题，差不多我们小组都奔溃，辛亏用了脱线的技巧)现在咋们来看标记16->标记17这段路，考虑是短转弯，我们就直接脱线了，因为前面标记中已经进行了很多次双标记切换，最后为了保证标记正确我直接选择脱线。脱线的算法思路就是到达转弯口先小转一点角度后直线冲出线外，然后利用双标记位进行脱线回正，这个大家在制作循迹加小车过程中都会接触到的，什么标记位，循迹的相关概念。

```C
//回家
              if(FC14 == 1 && FA5 == 0 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 44)
                                {
                                        delay_ms(10);
                                        if(FC14 == 1 && FA5 == 0)
                                        {
                                                        time = 14;//清除标记位
                                                        motor2 = -5500;
                                                        motor3 =  2000;
                                                        Set_Pwm(motor1,motor2,motor3);
                                                        delay_ms(400);
                                                        motor2 = -3700;
                                                        motor3 = -3500;
                                                        Set_Pwm(motor1,motor2,motor3);       
                                                        delay_ms(300);
                                                        Flag = 45;
                                        }
                                }
                                //硬掰回来
                        if(FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 45)
                        {
                                        delay_ms(10);
                                        if(FA5 == 1 && FA3 == 0)
                                        {
                                                        motor2 =  4800;
                                                        motor3 = -4500;
                                                        Set_Pwm(motor1,motor2,motor3);
                                                        time = 15;

                                        }
                        }
```





## 六路

①循迹最基本的要求就是车可以循迹且不脱离循迹轨迹，由于我们的结构是普通的两轮结构，这也存在了打滑、重心不稳的大问题，也就是说我们的车走直线都有点问题，解决的办法就是程序解决，也就是利用程序将车体打滑的轨迹强行纠正。大致思路就是利用前头3-6路传感器检测，车体偏移时传感器会检测到，检测到后就做出纠正，左偏就右纠正，右偏就左纠正，当然，纠正的程序需要增加一些判断机制，这样可以提高车的稳定度，不容易出现纠正过大导致出线的情况。纠正的车速也需要调节，不易过小，亲测是纠正速度大一点，这样比较有效，过小的话容易出现无法纠正的情况。建议采用是‘同向差速纠正’，最好不要用‘反向差速纠正’，同向纠正就可以保证车体运动轨迹一直保持向前，即使纠正过头也不会出现大幅度转弯。

```c
//纠正模式一（正头）        //1 2 3 | 4 5 6                
                     //  1 2 3 4 | 5 6 7 8       
                        if(FA5==1&&FA4==0&&FA3==0)        //往右偏-八路
                            
                        if(FA4==1&&FA3==0&&FA2==0)        //往右偏-六路
                        {
                                motor1 = 0;
                                motor2 =-5000;
                                motor3 =-3700;
                        }
                        if( FA4==0&&FA3==0&&FA2==1 )                        //往左偏
                        {
                                motor1 = 0;
                                motor2 =-3700;
                                motor3 =-5000;
                        }
                        if(FA4==0&&FA3==1&&FA2==0)
                        {
                                motor1 = 0;
                                motor2 =-3400;
                                motor3 =-3400;
                        }
                        Set_Pwm(motor1,motor2,motor3);
                        motor1 = 0;
```

 ②ok,第二部分就是标记路线了，所谓标记路线就是对一些路口进行标记，达到记忆的效果。经过我趴地研究，用局部路口标记的方式和特殊路口标记效率最大。所谓局部标记就是省略一些路口，不进行标记，特殊标记就是对T型，倒T等路口进行标记。标记如下图所示：

![微信截图_20190707152943.png](https://xiaopingtou.net/data/attach/1907/uufeeczkida0r2zriz1fax4ncdiyikvh.jpg?t=1689908439648)

大家看标记图和路线图，可以发现我把一些路口省略掉了。附上从绿 {MOD}区域出发到达标记1的代码。从代码上可以发现我用了二次检测的原理，也就是吧、判断了两次，嗯，这样可以提高系统的稳定性和判断的严谨性。首先看第一行 FC14 == 0 && FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 0，这个是运动到标记1位置，然后FA5 == 1 && FA3 == 0 && FC14 == 0二次判断，然后控制电机差速转向，注意time = 1这个语句，它起到很大作用，也就是保证转弯时车不会脱线，做过差速转弯的循迹小车的同学应该都知道，差速转弯十分不稳定，很容易脱线，基本要靠delay函数延迟（但是不好）加入第二个标记位判断可以保证车体脱线时硬生生“掰正”回来，这就是双标记位的使用，十分有效

```c
//顶角转弯直走1   黄 {MOD}圈
             if(FC14 == 0 && FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 0)
                 {
                    delay_ms(10);
                     if(FA5 == 1 && FA3 == 0 && FC14 == 0)
                      {
                            motor1 = 0;
                            motor2 = 4800;
                            motor3 = -4500;
                            Set_Pwm(motor1,motor2,motor3);

                             time = 1;
                       }
                  }       
```



③从黄 {MOD}区域到红 {MOD}区域，标记位2，从黄区-->红区，会经过几个路口，我采用忽略标记，不进行标记，大家仔细看程序会发现Flag和 time两个标记位在不断转换，它的作用就是上面提到的对差速转弯的打滑车进行强行掰正，这个是我们小组经过不断努力（掉了好多头发研究出来 的循迹模式-->硬掰模式,

大家主要看深蓝 {MOD}的代码那里，其他代码是机械臂抓物块以及停止的，可以不看，贴出来是给大家更加直观地知道整个执行流程以及两个标记位的互换。一般红外循迹小车都是利用delay函数来差速转弯，这个虽然可以，但是一旦车打滑就会出现转弯过大或者过小的情况，这样会影响后续的标记，十分麻烦（![img](https://xiaopingtou.net/data/attach/1907/bjlxkuvdvc0fxjdyp9l9vvukaiih56eg.jpg?t=1689908439648)亲测不可行)，但是利用两个标记位切换的话就可以实现转弯即使过大过小都可以硬生生掰会循迹路线，100%稳定且可行。

```c
//黄 {MOD}口停                       
                        if(FC14 == 0 && FA5 == 1 && FA3 == 1 && time == 1)
                        {
                                delay_ms(20);
                                if(FC14 == 0 && FA5 == 1)
                                {
                                       	Flag = 30;
                                        motor1 = 0;
                                        motor2 = 0;
                                        motor3 = 0;
                                        Set_Pwm(motor1,motor2,motor3);
                                       
                                        //0号盘下去
                                        //舵机归零

                                                                               
                                        motor2 = -3700;
                                  		motor3 = -2000;
                                        Set_Pwm(motor1,motor2,motor3);
                                        delay_ms(200);
                                       	time = 2;
                                }                                                               
                }
                       
               
//蓝 {MOD}口停
                if(FC14 == 1  && FA5 == 0 && time == 2)
                        {
                                delay_ms(20);
                                if(FC14 == 1&&FA5 == 0)
                                {
                                        Flag = 31;
                                        motor1 = 0;
                                        motor2 = 0;
                                        motor3 = 0;
                                        Set_Pwm(motor1,motor2,motor3);
                                       

                                        motor2 = -3700;
                                  		motor3 = -2000;
                                        Set_Pwm(motor1,motor2,motor3);
                                        delay_ms(100);
                                        time = 3;
                                }
                        }
                       
//红 {MOD}转弯               
              if(FC14 == 0 && FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 31)
                                {
                                        delay_ms(10);
                                        if(FA5 == 1 && FA3 == 0 && FC14 == 0)
                                        {
                                                motor1 = 0;
                                                motor2 = 4800;
                                                motor3 = -4500;
                                                Set_Pwm(motor1,motor2,motor3);

                                                time = 4;
                                        }
                                }        
                               
                                       
//红 {MOD}角停止       
            if(FC14 == 0 && FA5 == 1 && (FA3 == 1 || FA2 == 1 || FA4 == 1) && time == 4)
                        {
                                delay_ms(10);
                                if(FC14 == 0 && FA5 == 1)
                                {
//                                                Flag = 33;
                                                motor1 = 0;
                                                motor2 = 0;
                                                motor3 = 0;
                                                Set_Pwm(motor1,motor2,motor3);
                                                delay_ms(300);
                       
                                        Flag = 33;
//                                                time =  6;                               
                        }       
                }
```



 ④标记4--->标记9思路和上面一模一样，仅仅区别在一些标记延迟和标记判断上，区别不大，主要是2个标记位的切换需要技巧切换，不然车就会“迷路”，或者一直转圈圈，这里主要说下“脱线”的方法，如果觉得整段路一直循迹很无聊。那咋们就可以考虑下“脱线”，脱线，顾名思义就是脱离循迹路线一段时间后继续回到循迹路线，继续循迹。这个应用在多段短路线转弯口十分有用，因为多路的短转弯口如果还是照以前乖乖循迹就真的有点笨笨了，这样标记起来麻烦又容易出现问题，那还不如考虑脱线到稳定直线或者长转弯口再继续循迹（以前就是照旧没有脱线，然后出现很多问题，差不多我们小组都奔溃，辛亏用了脱线的技巧)现在咋们来看标记16->标记17这段路，考虑是短转弯，我们就直接脱线了，因为前面标记中已经进行了很多次双标记切换，最后为了保证标记正确我直接选择脱线。脱线的算法思路就是到达转弯口先小转一点角度后直线冲出线外，然后利用双标记位进行脱线回正，这个大家在制作循迹加小车过程中都会接触到的，什么标记位，循迹的相关概念。

```C
//回家
              if(FC14 == 1 && FA5 == 0 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 44)
                                {
                                        delay_ms(10);
                                        if(FC14 == 1 && FA5 == 0)
                                        {
                                                        time = 14;//清除标记位
                                                        motor2 = -5500;
                                                        motor3 =  2000;
                                                        Set_Pwm(motor1,motor2,motor3);
                                                        delay_ms(400);
                                                        motor2 = -3700;
                                                        motor3 = -3500;
                                                        Set_Pwm(motor1,motor2,motor3);       
                                                        delay_ms(300);
                                                        Flag = 45;
                                        }
                                }
                                //硬掰回来
                        if(FA5 == 1 && FA2 == 0 && FA3 == 0 && FA4 == 0 && Flag == 45)
                        {
                                        delay_ms(10);
                                        if(FA5 == 1 && FA3 == 0)
                                        {
                                                        motor2 =  4800;
                                                        motor3 = -4500;
                                                        Set_Pwm(motor1,motor2,motor3);
                                                        time = 15;

                                        }
                        }
```



